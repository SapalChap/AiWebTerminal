<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Web Terminal</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #fff !important;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            height: 100vh;
        }

        .terminal {
            height: 100vh;
            padding: 20px;
            background: #000;
        }

        .cursor {
            background-color: #fff;
            animation: blink 1s infinite;
            width: 8px;
            height: 16px;
            display: inline-block;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Loading indicator for when request is processing */
        .loading {
            color: #888 !important;
        }

        .response-text {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="terminal">
        <div>AI Web Terminal v1.2.0 : A minimal AI chatbot.</div>
        <div>Copyright (c) 2025 AI Web Terminal. All rights reserved.</div>
        <br>
        <div>System initialized successfully.</div>
        <div>Welcome to AI Minimal Terminal!</div>
        <div>Type !help for available commands</div>
        <div id="output"></div>
        <div style="display: flex; align-items: center; flex-wrap: nowrap;">
            <span style="white-space: nowrap; margin-right: 5px;">user@aiwebterminal:~$ </span>
            <input type="text" id="command-input" style="background: transparent; border: none; color: #fff; font-family: 'Courier New', monospace; font-size: 14px; outline: none; flex: 1; min-width: 200px;">
        </div>
    </div>

    <!-- Login Popup Modal -->
    <div id="loginModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8);">
        <div style="background-color: #111; margin: 10% auto; padding: 20px; border: 1px solid #333; width: 400px; border-radius: 5px;">
            <div style="color: #fff; margin-bottom: 20px;">
                <h3 style="color: #fff;">Login to AI Web Terminal</h3>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="color: #fff; display: block; margin-bottom: 5px;">Username:</label>
                <input type="text" id="loginUsername" style="width: 100%; padding: 8px; background: #222; border: 1px solid #555; color: #fff; border-radius: 3px; font-family: 'Courier New', monospace;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #fff; display: block; margin-bottom: 5px;">Password:</label>
                <input type="password" id="loginPassword" style="width: 100%; padding: 8px; background: #222; border: 1px solid #555; color: #fff; border-radius: 3px; font-family: 'Courier New', monospace;">
            </div>
            <div style="text-align: right;">
                <button onclick="closeLoginModal()" style="background: #666; color: #fff; border: none; padding: 8px 16px; margin-right: 10px; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace;">Cancel</button>
                <button onclick="submitLogin()" style="background: #0066cc; color: #fff; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer; font-family: 'Courier New', monospace;">Login</button>
            </div>
        </div>
    </div>

    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('command-input');
        
        // Track current AI model (default to llama)
        let currentModel = 'llama';
        
        // Track last AI response for copying
        let lastResponse = '';
        
        // Track ongoing request for cancellation
        let currentAbortController = null;
        let isProcessing = false;
        
        // Track user authentication status
        let isUserLoggedIn = false;
        let currentUser = null;
        
        // Track conversation context for each user
        let userContexts = {}; // Format: { username: [conversation_history] }
        
        // Global code block counter (increments when user copies code)
        let globalCodeBlockCounter = 0;

        // Function to extract specific code block from response
        function extractCodeBlock(responseText, blockNumber) {
            const regex = /```[\w\s]*:\s*code block (\d+) start\n([\s\S]*?)\n``` code block \1 end/g;
            let match;
            let currentBlock = 0;
            
            while ((match = regex.exec(responseText)) !== null) {
                currentBlock++;
                if (currentBlock === blockNumber) {
                    return match[2]; // Return the code content
                }
            }
            
            return null; // Block not found
        }

        // Function to count total code blocks in response
        function countCodeBlocks(responseText) {
            const regex = /```[\w\s]*:\s*code block (\d+) start\n([\s\S]*?)\n``` code block \1 end/g;
            let count = 0;
            while (regex.exec(responseText) !== null) {
                count++;
            }
            return count;
        }
        
        // Function to handle stop processing (shared by !stop command and Ctrl+C)
        function stopProcessing() {
            if (isProcessing && currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
                isProcessing = false;
                return 'Processing stopped.';
            } else {
                return 'No active processing to stop.';
            }
        }
        
        // Function to handle login
        async function handleLogin(username, password) {
            try {
                const response = await fetch('/login_user', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        username: username,
                        password: password
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    return `Login successful! Welcome back, ${data.user.name || username}.`;
                } else {
                    return `Login failed: ${data.error}`;
                }
            } catch (error) {
                console.error('Login error:', error);
                return 'Login failed: Unable to connect to server.';
            }
        }
        
        // Function to handle special commands (model switching, clear, etc.)
        function handleSpecialCommand(command) {
            const cmd = command.toLowerCase();
            
            // Handle model switching
            if (cmd.startsWith('!aimodel ')) {
                const modelName = cmd.split(' ')[1];
                
                // Check if it's a valid model
                const validModels = ['deepseek', 'llama', 'gemini'];
                
                if (validModels.includes(modelName)) {
                    currentModel = modelName;
                    return `Model switched to: ${modelName}`;
                } else {
                    return `Invalid model. Available models: ${validModels.join(', ')}`;
                }
            }
            
            // Handle clear command
            if (cmd === '!clear') {
                output.innerHTML = ''; // Clear all chat history
                lastResponse = ''; // Clear last response too
                
                // Clear conversation context for current user
                if (currentUser && userContexts[currentUser]) {
                    userContexts[currentUser] = [];
                }
                
                return 'Chat history and conversation context cleared.';
            }
            
            // Handle copy command
            if (cmd === '!copy') {
                if (lastResponse) {
                    // Copy to clipboard using the Clipboard API
                    navigator.clipboard.writeText(lastResponse).then(() => {
                        // Success handled by return statement below
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err);
                    });
                    return 'Last response copied to clipboard! (Ctrl+V to paste)';
                } else {
                    return 'No response to copy. Send a message first.';
                }
            }
            
            // Handle copy code command
            if (cmd.startsWith('!cc')) {
                const blockNumStr = cmd.replace('!cc', '');
                const blockNum = parseInt(blockNumStr);
                
                if (isNaN(blockNum) || blockNum < 1) {
                    return 'Invalid format. Use !cc1, !cc2, etc.';
                }
                
                if (!lastResponse) {
                    return 'No AI response to extract code from.';
                }
                
                const codeContent = extractCodeBlock(lastResponse, blockNum);
                
                if (codeContent) {
                    // Copy to clipboard
                    navigator.clipboard.writeText(codeContent).then(() => {
                        // Success handled by return statement below
                    }).catch(err => {
                        console.error('Failed to copy code to clipboard:', err);
                    });
                    
                    // Increment global counter only when successfully copying
                    globalCodeBlockCounter++;
                    
                    return `Code block ${blockNum} copied to clipboard! (Global copy #${globalCodeBlockCounter})`;
                } else {
                    const totalBlocks = countCodeBlocks(lastResponse);
                    if (totalBlocks === 0) {
                        return 'AI Web Terminal didn\'t find any code blocks.';
                    } else {
                        return `Code block ${blockNum} not found. Available blocks: 1-${totalBlocks}`;
                    }
                }
            }
            
            // Handle privacy policy command
            if (cmd === '!privacypolicy') {
                const privacyText = `PRIVACY POLICY - AI Web Terminal

Effective Date: September 2025

1. INFORMATION WE COLLECT
• Account Data: Username and email address (when you create an account)
• Technical Data: Browser info, IP address (temporary)
• We DO NOT collect or store: Your messages, commands, conversations, real names, phone numbers, files, or location data

2. HOW WE USE YOUR INFORMATION
• Username and email used only for account authentication
• Your messages sent directly to AI providers (OpenRouter API) for responses - we don't store them
• No permanent storage of conversations on our servers
• Session data cleared when browser closes

3. DATA SHARING
• Your messages go directly to OpenRouter API and AI models (DeepSeek, Llama, Gemini)
• Important: We have no control over how OpenRouter or AI model providers use your conversation data
• Account data (username/email) is NOT shared with AI providers or third parties
• No sharing with advertisers, marketers, or data brokers by us
• Review OpenRouter's privacy policy at https://openrouter.ai
• Review individual AI model provider policies for complete data handling information

4. DATA STORAGE
• Conversations exist only in your browser session - we don't store them
• Account data (username/email) stored securely in Supabase database
• Passwords are hashed using secure encryption - we cannot see your actual password
• Supabase handles data storage security - we have no control over their data practices
• Use !clear to delete conversation history from your browser anytime

5. SECURITY
• HTTPS encryption for all communications
• Passwords securely hashed and stored via Supabase
• API keys secured server-side
• We never see or store your actual conversations

6. YOUR RIGHTS
• Delete: Use !clear command for browser conversation history
• Stop: Use !stop or Ctrl+C
• Exit: Use !exit command
• Account data can be deleted by contacting us

7. THIRD-PARTY DATA HANDLING
• Important Disclaimer: Your messages are processed by third-party AI services
• We do not control how OpenRouter or AI model providers use your conversation data
• Each AI provider may have different data retention and usage policies
• We recommend reviewing their privacy policies before use
• Consider the sensitivity of information you share in conversations

8. THIRD-PARTY SERVICES
• Supabase: Handles secure user account storage and authentication only
• OpenRouter: Receives and processes your conversation messages directly
• We have no control over how these third-party services handle your data
• Review their privacy policies for complete information
• Supabase Privacy: https://supabase.com/privacy

9. CONTACT
For privacy questions, contact: sapalcdev@gmail.com

Type any key to continue or use !clear to return to terminal.`;
                return privacyText;
            }
            
            // Handle terms of use command
            if (cmd === '!termsofuse') {
                const termsText = `TERMS OF USE - AI Web Terminal

Effective Date: September 2025

1. ACCEPTANCE
By using AI Web Terminal, you agree to these terms.

2. SERVICE DESCRIPTION
Free, minimalist web interface for AI conversations with terminal commands.

3. ACCEPTABLE USE
✓ PERMITTED: General questions, programming help, education, creative writing
✗ PROHIBITED: Illegal content, harassment, system attacks, spam, malicious code

4. SERVICE AVAILABILITY
• Provided "as-is" without uptime guarantees
• Subject to OpenRouter API rate limits
• Free tier models may have restrictions

5. USER RESPONSIBILITIES
• You're responsible for your input messages
• Comply with all applicable laws
• Respect third-party AI provider terms

6. THIRD-PARTY SERVICES
• Relies on OpenRouter and connected AI models
• Subject to their terms of service
• We're not responsible for third-party issues

7. DISCLAIMERS
• AI responses may contain errors - verify important information
• No warranties provided
• Service provided "as-is"

8. LIMITATION OF LIABILITY
• Not liable for AI response accuracy
• Not liable for service interruptions
• Maximum liability: $0 (free service)

9. PRIVACY
• No permanent data storage
• Session-based operation only
• See !privacypolicy for details

10. CONTACT
Questions: sapalcdev@gmail.com

Type any key to continue or use !clear to return to terminal.`;
                return termsText;
            }
            
            // Handle login command - show popup
            if (cmd === '!login') {
                showLoginModal();
                return 'Login popup opened. Enter your credentials.';
            }
            
            // Handle help command
            if (cmd === '!help') {
                const helpText = `Available Commands:

!help - Show this help message.

!login - Open login popup to enter your credentials

!aimodel [model] - Switch AI model (deepseek, llama, gemini). Ex: !aimodel deepseek

!clear - Clear chat history

!copy - Copy last response to clipboard

!cc[n] - Copy code block n to clipboard. Ex: !cc1, !cc2

!stop - Stop current AI processing 
or 
CTRL + C (Cmd + C on Mac) - Also stops AI processing 

!privacypolicy - View privacy policy

!termsofuse - View terms of use

!viewupdatehistory - View update history 

!exit - Exit the terminal

For support/ feature requests, send me an email: sapalcdev@gmail.com

Created by SapalChap

Just type your message to chat with the AI!`;
                return helpText;
            }

            if (cmd === '!viewupdatehistory') {
                const updateHistory = `
1.2.0 - Added a marketing page, login, and forgot password functionality
1.1.0 - Made it so the web app deploys on gunicorn
      - Added update history command
1.0.0 - Initial release`;
                return updateHistory;
            }
            
            // Handle stop command
            if (cmd === '!stop') {
                return stopProcessing();
            }
            
            // Handle exit command
            if (cmd === '!exit') {
                // Show goodbye message first
                setTimeout(() => {
                    // Try to close the window/tab
                    window.close();
                    
                    // If window.close() doesn't work (due to browser restrictions),
                    // show alternative instructions
                    setTimeout(() => {
                        const exitMessage = document.createElement('div');
                        exitMessage.textContent = 'Auto window close was blocked by your browser. Please close this browser tab manually (Ctrl+W or click the X button). Thank you for using AI Web Terminal!';
                        exitMessage.style.color = '#ff6666';
                        output.appendChild(exitMessage);
                    }, 500);
                }, 1000);
                
                return 'Thanks for using AI Web Terminal! Closing...';
            }
            
            // Check if command starts with ! but is not a valid command
            if (cmd.startsWith('!')) {
                return 'Not a valid command. Type !help for documentation.';
            }
            
            return null; // Not a special command
        }
        
        // Function to send command to Flask backend
        async function executeCommand(command) {
            try {
                // Create new AbortController for this request
                currentAbortController = new AbortController();
                isProcessing = true;
                
                const response = await fetch('/execute_command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        command: command,
                        model: currentModel,  // Send current model to Flask
                        context: currentUser ? (userContexts[currentUser] || []) : [],  // Send conversation context
                        username: currentUser  // Send username for context tracking
                    }),
                    signal: currentAbortController.signal  // Add abort signal
                });
                
                const data = await response.json();
                
                // Reset processing state
                isProcessing = false;
                currentAbortController = null;
                
                if (data.success) {
                    return data.response;
                } else {
                    return 'Error: Command execution failed';
                }
            } catch (error) {
                // Reset processing state
                isProcessing = false;
                currentAbortController = null;
                
                if (error.name === 'AbortError') {
                    return 'Request was cancelled.';
                }
                
                console.error('Error:', error);
                return 'Error: Failed to communicate with server';
            }
        }
        
        // Handle Enter key press
        input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                const command = input.value.trim();
                
                if (command === '') return;
                
                // Add command to output
                const commandLine = document.createElement('div');
                const username = isUserLoggedIn && currentUser ? currentUser.toLowerCase() : 'user';
                commandLine.textContent = `${username}@aiwebterminal:~$ ${command}`;
                output.appendChild(commandLine);
                autoScrollToBottom();
                
                // Clear input immediately after capturing command
                input.value = '';
                
                // Check if it's a special command (model switching, clear, etc.)
                const specialResponse = await handleSpecialCommand(command);
                
                if (specialResponse) {
                    // Handle special commands locally
                    const responseLine = document.createElement('div');
                    responseLine.textContent = specialResponse;
                    responseLine.style.color = '#00ff00'; // Green color for system messages
                    responseLine.style.whiteSpace = 'pre-wrap'; // Preserve line breaks and formatting
                    output.appendChild(responseLine);
                    autoScrollToBottom();
                } else {
                    // Check authentication before AI commands
                    const authCheck = requireAuthentication(command);
                    if (authCheck) {
                        const responseLine = document.createElement('div');
                        responseLine.textContent = authCheck;
                        responseLine.style.color = '#ff6666'; // Red color for auth error
                        responseLine.style.whiteSpace = 'pre-wrap';
                        output.appendChild(responseLine);
                        autoScrollToBottom();
                        return;
                    }
                    
                    // Show loading indicator for AI requests
                    const loadingLine = document.createElement('div');
                    loadingLine.textContent = 'Processing...';
                    loadingLine.className = 'loading';
                    output.appendChild(loadingLine);
                    
                    try {
                        // Execute command via Flask backend
                        const response = await executeCommand(command);
                        
                        // Store response for copying
                        lastResponse = response;
                        
                        // Store conversation in user context
                        if (currentUser && userContexts[currentUser]) {
                            userContexts[currentUser].push({
                                role: 'user',
                                content: command
                            });
                            userContexts[currentUser].push({
                                role: 'assistant', 
                                content: response
                            });
                            
                            // Keep only last 20 messages to prevent memory issues
                            if (userContexts[currentUser].length > 20) {
                                userContexts[currentUser] = userContexts[currentUser].slice(-20);
                            }
                        }
                        
                        // Remove loading indicator if it still exists
                        if (loadingLine.parentNode) {
                            output.removeChild(loadingLine);
                        }
                        
                        // Add response to output
                        const responseLine = document.createElement('div');
                        responseLine.textContent = response;
                        responseLine.style.whiteSpace = 'pre-wrap'; // Preserve formatting
                        output.appendChild(responseLine);
                        autoScrollToBottom();
                    } catch (error) {
                        // Remove loading indicator if it still exists
                        if (loadingLine.parentNode) {
                            output.removeChild(loadingLine);
                        }
                        
                        // Show error message
                        const errorLine = document.createElement('div');
                        errorLine.textContent = 'Request was cancelled or failed.';
                        errorLine.style.color = '#ff6666';
                        output.appendChild(errorLine);
                        autoScrollToBottom();
                    }
                }
                
                autoScrollToBottom();
            }
        });

        // Function to auto-scroll terminal to bottom
        function autoScrollToBottom() {
            // Use setTimeout to ensure DOM is updated before scrolling
            setTimeout(() => {
                // Fixed: Scroll the window to the bottom of the page instead of the output div
                // The output div has no height constraints or overflow settings, making it non-scrollable
                window.scrollTo({
                    top: document.body.scrollHeight,
                    behavior: 'smooth' // Adds smooth scrolling animation
                });
            }, 10);
        }

        // Function to update terminal prompt with current user
        function updateTerminalPrompt() {
            const promptSpan = document.querySelector('span[style*="white-space: nowrap"]');
            if (promptSpan) {
                const username = isUserLoggedIn && currentUser ? currentUser.toLowerCase() : 'user';
                promptSpan.textContent = `${username}@aiwebterminal:~$ `;
            }
        }

        // Keep input focused
        input.focus();
        
        // Refocus input when clicking anywhere on terminal
        document.addEventListener('click', () => {
            input.focus();
        });

        // Handle Ctrl+C keypress globally to stop processing
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl+C (or Cmd+C on Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                // Only intercept Ctrl+C if we're currently processing AI request
                if (isProcessing) {
                    e.preventDefault(); // Prevent default copy behavior
                    
                    // Stop the processing
                    const stopMessage = stopProcessing();
                    
                    // Display the stop message in terminal
                    const responseLine = document.createElement('div');
                    responseLine.textContent = stopMessage;
                    responseLine.style.color = '#ff6666'; // Red color for interruption
                    output.appendChild(responseLine);
                    
                    // Scroll to bottom using the fixed auto-scroll function
                    autoScrollToBottom();
                }
                // If not processing, let Ctrl+C work normally (copy to clipboard)
            }
        });

        // Function to check if user is authenticated before AI commands
        function requireAuthentication(command) {
            if (!isUserLoggedIn) {
                return `Please create an account first by going to https://aiwebterminal.onrender.com/ and then use !login to login to your account.`;
            }
            return null; // User is authenticated, proceed
        }

        // Functions for login modal
        function showLoginModal() {
            document.getElementById('loginModal').style.display = 'block';
            document.getElementById('loginUsername').focus();
        }

        function closeLoginModal() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('loginUsername').value = '';
            document.getElementById('loginPassword').value = '';
        }

        async function submitLogin() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!username || !password) {
                alert('Please enter both username and password');
                return;
            }
            
            try {
                // Show loading in modal
                const loginResult = await handleLogin(username, password);
                
                // Close modal and show result in terminal
                closeLoginModal();
                
                // Check if login was successful and update status
                if (loginResult.includes('successful')) {
                    isUserLoggedIn = true;
                    currentUser = username;
                    
                    // Initialize conversation context for this user if not exists
                    if (!userContexts[username]) {
                        userContexts[username] = [];
                    }
                    
                    // Update terminal prompt to show real username
                    updateTerminalPrompt();
                }
                
                // Add result to terminal output
                const responseLine = document.createElement('div');
                responseLine.textContent = loginResult;
                responseLine.style.color = loginResult.includes('successful') ? '#00ff00' : '#ff6666';
                output.appendChild(responseLine);
                autoScrollToBottom();
            } catch (error) {
                alert('Login failed: Unable to connect to server');
                console.error('Login error:', error);
            }
        }

        // Allow Enter key to submit login in modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('loginModal').style.display === 'block') {
                e.preventDefault();
                submitLogin();
            }
        });
    </script>
</body>
</html>